// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
part of 'chess_engine.dart'; // Line added by EJRP
/// Bindings to a native chess engine
class _NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  _NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  _NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  void magicBitBoardInitialize() {
    return _magicBitBoardInitialize();
  }

  late final _magicBitBoardInitializePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'magicBitBoardInitialize');
  late final _magicBitBoardInitialize =
      _magicBitBoardInitializePtr.asFunction<void Function()>();

  void magicBitBoardTerminate() {
    return _magicBitBoardTerminate();
  }

  late final _magicBitBoardTerminatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'magicBitBoardTerminate');
  late final _magicBitBoardTerminate =
      _magicBitBoardTerminatePtr.asFunction<void Function()>();

  late final ffi.Pointer<ffi.Pointer<ffi.Uint64>> _kingMovementMask =
      _lookup<ffi.Pointer<ffi.Uint64>>('kingMovementMask');

  ffi.Pointer<ffi.Uint64> get kingMovementMask => _kingMovementMask.value;

  set kingMovementMask(ffi.Pointer<ffi.Uint64> value) =>
      _kingMovementMask.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Uint64>> _knightMovementMask =
      _lookup<ffi.Pointer<ffi.Uint64>>('knightMovementMask');

  ffi.Pointer<ffi.Uint64> get knightMovementMask => _knightMovementMask.value;

  set knightMovementMask(ffi.Pointer<ffi.Uint64> value) =>
      _knightMovementMask.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Uint64>> _rookMovementMask =
      _lookup<ffi.Pointer<ffi.Uint64>>('rookMovementMask');

  ffi.Pointer<ffi.Uint64> get rookMovementMask => _rookMovementMask.value;

  set rookMovementMask(ffi.Pointer<ffi.Uint64> value) =>
      _rookMovementMask.value = value;

  int getRookPseudoLegalMovesBitBoard(
    int position,
    int blockingBitBoard,
  ) {
    return _getRookPseudoLegalMovesBitBoard(
      position,
      blockingBitBoard,
    );
  }

  late final _getRookPseudoLegalMovesBitBoardPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Int, ffi.Uint64)>>(
          'getRookPseudoLegalMovesBitBoard');
  late final _getRookPseudoLegalMovesBitBoard =
      _getRookPseudoLegalMovesBitBoardPtr.asFunction<int Function(int, int)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Uint64>> _bishopMovementMask =
      _lookup<ffi.Pointer<ffi.Uint64>>('bishopMovementMask');

  ffi.Pointer<ffi.Uint64> get bishopMovementMask => _bishopMovementMask.value;

  set bishopMovementMask(ffi.Pointer<ffi.Uint64> value) =>
      _bishopMovementMask.value = value;

  int getBishopPseudoLegalMovesBitBoard(
    int position,
    int blockingBitBoard,
  ) {
    return _getBishopPseudoLegalMovesBitBoard(
      position,
      blockingBitBoard,
    );
  }

  late final _getBishopPseudoLegalMovesBitBoardPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Int, ffi.Uint64)>>(
          'getBishopPseudoLegalMovesBitBoard');
  late final _getBishopPseudoLegalMovesBitBoard =
      _getBishopPseudoLegalMovesBitBoardPtr
          .asFunction<int Function(int, int)>();

  /// Sets ups the chess position currently from a fen string.
  /// Returns true if the fenstring is valid and result != NULL
  bool setChessPositionFromFenString(
    ffi.Pointer<ffi.Char> fenString,
    ffi.Pointer<ChessPosition> result,
  ) {
    return _setChessPositionFromFenString(
      fenString,
      result,
    );
  }

  late final _setChessPositionFromFenStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ChessPosition>)>>('setChessPositionFromFenString');
  late final _setChessPositionFromFenString =
      _setChessPositionFromFenStringPtr.asFunction<
          bool Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ChessPosition>)>();

  /// Returns the bit board of a specific piece
  int bitBoardForPiece(
    Board board,
    int piece,
  ) {
    return _bitBoardForPiece(
      board,
      piece,
    );
  }

  late final _bitBoardForPiecePtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(Board, Piece)>>(
          'bitBoardForPiece');
  late final _bitBoardForPiece =
      _bitBoardForPiecePtr.asFunction<int Function(Board, int)>();

  int specificColorBitBoard(
    Board board,
    int color,
  ) {
    return _specificColorBitBoard(
      board,
      color,
    );
  }

  late final _specificColorBitBoardPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(Board, ffi.Int32)>>(
          'specificColorBitBoard');
  late final _specificColorBitBoard =
      _specificColorBitBoardPtr.asFunction<int Function(Board, int)>();

  int allPiecesBitBoard(
    Board board,
  ) {
    return _allPiecesBitBoard(
      board,
    );
  }

  late final _allPiecesBitBoardPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(Board)>>(
          'allPiecesBitBoard');
  late final _allPiecesBitBoard =
      _allPiecesBitBoardPtr.asFunction<int Function(Board)>();

  /// Returns the piece at a specific index
  int pieceAtIndex(
    Board board,
    int index,
  ) {
    return _pieceAtIndex(
      board,
      index,
    );
  }

  late final _pieceAtIndexPtr =
      _lookup<ffi.NativeFunction<Piece Function(Board, ffi.Int)>>(
          'pieceAtIndex');
  late final _pieceAtIndex =
      _pieceAtIndexPtr.asFunction<int Function(Board, int)>();

  /// Will toggle (XOR with 1) the bits at a specific index for a piece to the opposite state.
  /// If you pass in the NOPIECE piece (0) it will lead to undefined behaviour
  void togglePieceAtIndex(
    ffi.Pointer<Board> board,
    int index,
    int piece,
  ) {
    return _togglePieceAtIndex(
      board,
      index,
      piece,
    );
  }

  late final _togglePieceAtIndexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<Board>, ffi.Int, Piece)>>('togglePieceAtIndex');
  late final _togglePieceAtIndex = _togglePieceAtIndexPtr
      .asFunction<void Function(ffi.Pointer<Board>, int, int)>();

  /// Converts and puts the information in the piece's `array` to the `result` board.
  /// The index of a piece in the array represents its position on the board.
  /// 0 is the top left corner, and 63 is the bottom right corner.
  void fromArray(
    ffi.Pointer<Board> result,
    ffi.Pointer<Piece> array,
  ) {
    return _fromArray(
      result,
      array,
    );
  }

  late final _fromArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<Board>, ffi.Pointer<Piece>)>>('fromArray');
  late final _fromArray = _fromArrayPtr
      .asFunction<void Function(ffi.Pointer<Board>, ffi.Pointer<Piece>)>();

  /// Setups a chess game from the position specified by the fen string
  ffi.Pointer<ChessGame> setupChesGame(
    ffi.Pointer<ChessGame> result,
    ffi.Pointer<ffi.Char> fenString,
  ) {
    return _setupChesGame(
      result,
      fenString,
    );
  }

  late final _setupChesGamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ChessGame> Function(
              ffi.Pointer<ChessGame>, ffi.Pointer<ffi.Char>)>>('setupChesGame');
  late final _setupChesGame = _setupChesGamePtr.asFunction<
      ffi.Pointer<ChessGame> Function(
          ffi.Pointer<ChessGame>, ffi.Pointer<ffi.Char>)>();

  /// Correctly frees the chessGame structs. The argument will also be freed
  void freeChessGame(
    ffi.Pointer<ChessGame> chessGame,
  ) {
    return _freeChessGame(
      chessGame,
    );
  }

  late final _freeChessGamePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ChessGame>)>>(
          'freeChessGame');
  late final _freeChessGame =
      _freeChessGamePtr.asFunction<void Function(ffi.Pointer<ChessGame>)>();

  late final ffi.Pointer<ffi.Pointer<ZobristRandomNumber>>
      _zobristRandomNumber =
      _lookup<ffi.Pointer<ZobristRandomNumber>>('zobristRandomNumber');

  ffi.Pointer<ZobristRandomNumber> get zobristRandomNumber =>
      _zobristRandomNumber.value;

  set zobristRandomNumber(ffi.Pointer<ZobristRandomNumber> value) =>
      _zobristRandomNumber.value = value;

  void zobristKeyInitialize() {
    return _zobristKeyInitialize();
  }

  late final _zobristKeyInitializePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('zobristKeyInitialize');
  late final _zobristKeyInitialize =
      _zobristKeyInitializePtr.asFunction<void Function()>();

  void zobristKeyTerminate() {
    return _zobristKeyTerminate();
  }

  late final _zobristKeyTerminatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('zobristKeyTerminate');
  late final _zobristKeyTerminate =
      _zobristKeyTerminatePtr.asFunction<void Function()>();

  /// This function should be called only once when creating the your initial ChessGame struct
  /// Subsequent Zobrist key will be calculated by the makeMove function incrementally
  void calculateZobristKey(
    ffi.Pointer<ChessPosition> state,
  ) {
    return _calculateZobristKey(
      state,
    );
  }

  late final _calculateZobristKeyPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ChessPosition>)>>(
      'calculateZobristKey');
  late final _calculateZobristKey = _calculateZobristKeyPtr
      .asFunction<void Function(ffi.Pointer<ChessPosition>)>();

  /// Returns the best move in a position (according to the computer)
  /// TODO: Implement time control later
  int think(
    ffi.Pointer<ChessGame> game,
  ) {
    return _think(
      game,
    );
  }

  late final _thinkPtr =
      _lookup<ffi.NativeFunction<Move Function(ffi.Pointer<ChessGame>)>>(
          'think');
  late final _think =
      _thinkPtr.asFunction<int Function(ffi.Pointer<ChessGame>)>();

  /// Returns a score that was calculated by statically analyzing the position.
  /// Static analysis means only looking at information curently available, not considering
  /// potential good moves in the score.
  int staticEvaluation(
    ffi.Pointer<ChessGame> game,
  ) {
    return _staticEvaluation(
      game,
    );
  }

  late final _staticEvaluationPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ChessGame>)>>(
          'staticEvaluation');
  late final _staticEvaluation =
      _staticEvaluationPtr.asFunction<int Function(ffi.Pointer<ChessGame>)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Int>>> _pieceSquareTable =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Int>>>('pieceSquareTable');

  ffi.Pointer<ffi.Pointer<ffi.Int>> get pieceSquareTable =>
      _pieceSquareTable.value;

  set pieceSquareTable(ffi.Pointer<ffi.Pointer<ffi.Int>> value) =>
      _pieceSquareTable.value = value;

  void pieceSquareTableInitialize() {
    return _pieceSquareTableInitialize();
  }

  late final _pieceSquareTableInitializePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'pieceSquareTableInitialize');
  late final _pieceSquareTableInitialize =
      _pieceSquareTableInitializePtr.asFunction<void Function()>();

  /// Returns true if the friendly king (for the current turn) is in check
  /// Only valid after getValidMoves is called
  bool isKingInCheck() {
    return _isKingInCheck();
  }

  late final _isKingInCheckPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('isKingInCheck');
  late final _isKingInCheck = _isKingInCheckPtr.asFunction<bool Function()>();

  /// Returns true if the friendly king (for the current turn) is in double check
  /// Only valid after getValidMoves is called
  bool isKingInDoubleCheck() {
    return _isKingInDoubleCheck();
  }

  late final _isKingInDoubleCheckPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('isKingInDoubleCheck');
  late final _isKingInDoubleCheck =
      _isKingInDoubleCheckPtr.asFunction<bool Function()>();

  /// Computes the valid moves in a given position and stores the moves in the result array
  /// and the amount of moves in the numMoves pointer
  void getValidMoves(
    ffi.Pointer<Move> result,
    ffi.Pointer<ffi.Int> numMoves,
    ffi.Pointer<ChessGame> game,
  ) {
    return _getValidMoves(
      result,
      numMoves,
      game,
    );
  }

  late final _getValidMovesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Move>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ChessGame>)>>('getValidMoves');
  late final _getValidMoves = _getValidMovesPtr.asFunction<
      void Function(
          ffi.Pointer<Move>, ffi.Pointer<ffi.Int>, ffi.Pointer<ChessGame>)>();

  /// Makes the move and updates the ChessGame
  /// The move is assumed to be legal
  void playMove(
    int move,
    ffi.Pointer<ChessGame> game,
  ) {
    return _playMove(
      move,
      game,
    );
  }

  late final _playMovePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Move, ffi.Pointer<ChessGame>)>>(
      'playMove');
  late final _playMove =
      _playMovePtr.asFunction<void Function(int, ffi.Pointer<ChessGame>)>();

  void initializeFFILogging(ffi.Pointer printWrapper) {
    return _initializeFFILogging(printWrapper);
  }

  late final _initializeFFILoggingPtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer)>>("initializeFFILogging");
  late final _initializeFFILogging = _initializeFFILoggingPtr.asFunction<void Function(ffi.Pointer)>();
}

final class ChessPosition extends ffi.Struct {
  external Board board;

  @ffi.Int32()
  external int colorToGo;

  @ffi.Char()
  external int castlingPerm;

  @ffi.Int()
  external int enPassantTargetSquare;

  @ffi.Int()
  external int turnsForFiftyRule;

  @ffi.Int()
  external int nbMoves;

  @ZobristKey()
  external int key;
}

/// A struct which holds the information of the chess board, so which piece is at which square.
/// Use the pieceAtIndex function to extract that information
final class Board extends ffi.Struct {
  @ffi.Array.multi([14])
  external ffi.Array<ffi.Uint64> bitboards;
}

abstract class PieceCharacteristics {
  static const int NOPIECE = 0;
  static const int PAWN = 1;
  static const int KNIGHT = 2;
  static const int BISHOP = 3;
  static const int ROOK = 4;
  static const int QUEEN = 5;
  static const int KING = 6;
  static const int WHITE = 8;
  static const int BLACK = 16;
}

typedef ZobristKey = ffi.Uint64;
typedef DartZobristKey = int;

/// A piece is char that contains the color and the type of the piece.
/// The piece type is in the first 3 least significant bits.
/// The piece color is the next 2 bits that follow the piece type bits
/// The first 3 most significant bits of the char are unused.
/// Use the pieceColor(piece) function or pieceType(piece) function to extract those information
/// Use the makePiece(color, type) function to create a valid Piece
typedef Piece = ffi.Char;
typedef DartPiece = int;

/// Represents a game of chess.
/// currentState holds all information of a position (same information that is in a fen string)
/// Zobrist keys are used to quickly compute repetitions
final class ChessGame extends ffi.Struct {
  external ffi.Pointer<ChessPosition> currentState;

  external ffi.Pointer<ZobristKey> previousStates;

  @ffi.Int()
  external int previousStatesCount;

  @ffi.Int()
  external int previousStatesCapacity;
}

final class ZobristRandomNumber extends ffi.Struct {
  @ffi.Array.multi([9])
  external ffi.Array<ffi.Uint64> enPassantFile;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint64> castlingPerms;

  @ffi.Array.multi([14, 64])
  external ffi.Array<ffi.Array<ffi.Uint64>> pieces;

  @ffi.Uint64()
  external int sideToMove;
}

/// The structure is copied from Sebastian Lague chess program
/// A move is a 16 bit number
/// bit 0-5: from square (0 to 63)
/// bit 6-11: to square (0 to 63)
/// bit 12-15: flag
typedef Move = ffi.UnsignedShort;
typedef DartMove = int;

const int MIDGAME = 0;

const int ENGGAME = 1;

const int NB_PHASE = 2;
