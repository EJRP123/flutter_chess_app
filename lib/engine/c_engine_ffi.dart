// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
part of 'chess_engine.dart'; // Line added by EJRP

/// Bindings to a native chess engine
class _NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  _NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  _NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<Moves> getValidMoves(
    ffi.Pointer<GameState> gameState,
    ffi.Pointer<GameStates> previousStates,
  ) {
    return _getValidMoves(
      gameState,
      previousStates,
    );
  }

  late final _getValidMovesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Moves> Function(ffi.Pointer<GameState>,
              ffi.Pointer<GameStates>)>>('getValidMoves');
  late final _getValidMoves = _getValidMovesPtr.asFunction<
      ffi.Pointer<Moves> Function(
          ffi.Pointer<GameState>, ffi.Pointer<GameStates>)>();

  ffi.Pointer<GameState> createState(
    ffi.Pointer<ffi.Int> boardArray,
    int colorToGo,
    int castlingPerm,
    int enPassantTargetSquare,
    int turnsForFiftyRule,
    int nbMoves,
  ) {
    return _createState(
      boardArray,
      colorToGo,
      castlingPerm,
      enPassantTargetSquare,
      turnsForFiftyRule,
      nbMoves,
    );
  }

  late final _createStatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GameState> Function(ffi.Pointer<ffi.Int>, ffi.Int,
              ffi.Int, ffi.Int, ffi.Int, ffi.Int)>>('createState');
  late final _createState = _createStatePtr.asFunction<
      ffi.Pointer<GameState> Function(
          ffi.Pointer<ffi.Int>, int, int, int, int, int)>();

  /// Utility function to make a copy of a GameState
  GameState copyState(
    GameState from,
  ) {
    return _copyState(
      from,
    );
  }

  late final _copyStatePtr =
      _lookup<ffi.NativeFunction<GameState Function(GameState)>>('copyState');
  late final _copyState =
      _copyStatePtr.asFunction<GameState Function(GameState)>();

  ffi.Pointer<GameState> setGameStateFromFenString(
    ffi.Pointer<ffi.Char> fenString,
    ffi.Pointer<GameState> result,
  ) {
    return _setGameStateFromFenString(
      fenString,
      result,
    );
  }

  late final _setGameStateFromFenStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<GameState> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<GameState>)>>('setGameStateFromFenString');
  late final _setGameStateFromFenString =
      _setGameStateFromFenStringPtr.asFunction<
          ffi.Pointer<GameState> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<GameState>)>();

  void makeMove(
    int move,
    ffi.Pointer<GameState> state,
  ) {
    return _makeMove(
      move,
      state,
    );
  }

  late final _makeMovePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Move, ffi.Pointer<GameState>)>>(
      'makeMove');
  late final _makeMove =
      _makeMovePtr.asFunction<void Function(int, ffi.Pointer<GameState>)>();

  ffi.Pointer<Moves> bestMovesAccordingToComputer(
    int depth,
    ffi.Pointer<GameState> state,
    ffi.Pointer<GameStates> previousStates,
  ) {
    return _bestMovesAccordingToComputer(
      depth,
      state,
      previousStates,
    );
  }

  late final _bestMovesAccordingToComputerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<Moves> Function(ffi.Int, ffi.Pointer<GameState>,
              ffi.Pointer<GameStates>)>>('bestMovesAccordingToComputer');
  late final _bestMovesAccordingToComputer =
      _bestMovesAccordingToComputerPtr.asFunction<
          ffi.Pointer<Moves> Function(
              int, ffi.Pointer<GameState>, ffi.Pointer<GameStates>)>();
}

/// Dynamic array of moves. Use the da_append macro to append moves
class moves extends ffi.Struct {
  external ffi.Pointer<Move> items;

  @ffi.Size()
  external int count;

  @ffi.Size()
  external int capacity;
}

/// The structure is copied from Sebastian Lague chess program
/// A move is a 16 bit number
/// bit 0-5: from square (0 to 63)
/// bit 6-11: to square (0 to 63)
/// bit 12-15: flag
typedef Move = ffi.UnsignedShort;

class GameState extends ffi.Struct {
  external ffi.Pointer<ffi.Int> boardArray;

  @ffi.Int()
  external int colorToGo;

  @ffi.Int()
  external int castlingPerm;

  @ffi.Int()
  external int enPassantTargetSquare;

  @ffi.Int()
  external int turnsForFiftyRule;

  @ffi.Int()
  external int nbMoves;
}

/// Dynamic array of GameState. Use the da_append macro to append GameState
class gameStates extends ffi.Struct {
  external ffi.Pointer<GameState> items;

  @ffi.Size()
  external int count;

  @ffi.Size()
  external int capacity;
}

/// Dynamic array of moves. Use the da_append macro to append moves
typedef Moves = moves;

/// Dynamic array of GameState. Use the da_append macro to append GameState
typedef GameStates = gameStates;

const int BOARD_SIZE = 64;

const int _pieceColorBitMask = 24;

const int _pieceTypeBitMask = 7;
