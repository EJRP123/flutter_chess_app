// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
part of 'chess_engine.dart'; // Line added by EJRP

/// Bindings to a native chess engine
class _NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  _NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  _NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  void magicBitBoardInitialize() {
    return _magicBitBoardInitialize();
  }

  late final _magicBitBoardInitializePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'magicBitBoardInitialize');
  late final _magicBitBoardInitialize =
      _magicBitBoardInitializePtr.asFunction<void Function()>();

  void magicBitBoardTerminate() {
    return _magicBitBoardTerminate();
  }

  late final _magicBitBoardTerminatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>(
          'magicBitBoardTerminate');
  late final _magicBitBoardTerminate =
      _magicBitBoardTerminatePtr.asFunction<void Function()>();

  late final ffi.Pointer<ffi.Pointer<ffi.Uint64>> _kingMovementMask =
      _lookup<ffi.Pointer<ffi.Uint64>>('kingMovementMask');

  ffi.Pointer<ffi.Uint64> get kingMovementMask => _kingMovementMask.value;

  set kingMovementMask(ffi.Pointer<ffi.Uint64> value) =>
      _kingMovementMask.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Uint64>> _knightMovementMask =
      _lookup<ffi.Pointer<ffi.Uint64>>('knightMovementMask');

  ffi.Pointer<ffi.Uint64> get knightMovementMask => _knightMovementMask.value;

  set knightMovementMask(ffi.Pointer<ffi.Uint64> value) =>
      _knightMovementMask.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Uint64>> _rookMovementMask =
      _lookup<ffi.Pointer<ffi.Uint64>>('rookMovementMask');

  ffi.Pointer<ffi.Uint64> get rookMovementMask => _rookMovementMask.value;

  set rookMovementMask(ffi.Pointer<ffi.Uint64> value) =>
      _rookMovementMask.value = value;

  int getRookPseudoLegalMovesBitBoard(
    int position,
    int blockingBitBoard,
  ) {
    return _getRookPseudoLegalMovesBitBoard(
      position,
      blockingBitBoard,
    );
  }

  late final _getRookPseudoLegalMovesBitBoardPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Int, ffi.Uint64)>>(
          'getRookPseudoLegalMovesBitBoard');
  late final _getRookPseudoLegalMovesBitBoard =
      _getRookPseudoLegalMovesBitBoardPtr.asFunction<int Function(int, int)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Uint64>> _bishopMovementMask =
      _lookup<ffi.Pointer<ffi.Uint64>>('bishopMovementMask');

  ffi.Pointer<ffi.Uint64> get bishopMovementMask => _bishopMovementMask.value;

  set bishopMovementMask(ffi.Pointer<ffi.Uint64> value) =>
      _bishopMovementMask.value = value;

  int getBishopPseudoLegalMovesBitBoard(
    int position,
    int blockingBitBoard,
  ) {
    return _getBishopPseudoLegalMovesBitBoard(
      position,
      blockingBitBoard,
    );
  }

  late final _getBishopPseudoLegalMovesBitBoardPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Int, ffi.Uint64)>>(
          'getBishopPseudoLegalMovesBitBoard');
  late final _getBishopPseudoLegalMovesBitBoard =
      _getBishopPseudoLegalMovesBitBoardPtr
          .asFunction<int Function(int, int)>();

  /// Sets ups the chess position currently from a fen string.
  /// Returns true if the fenstring is valid and result != NULL
  bool setChessPositionFromFenString(
    ffi.Pointer<ffi.Char> fenString,
    ffi.Pointer<ChessPosition> result,
  ) {
    return _setChessPositionFromFenString(
      fenString,
      result,
    );
  }

  late final _setChessPositionFromFenStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ChessPosition>)>>('setChessPositionFromFenString');
  late final _setChessPositionFromFenString =
      _setChessPositionFromFenStringPtr.asFunction<
          bool Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ChessPosition>)>();

  /// Returns the bit board of a specific piece
  int bitBoardForPiece(
    Board board,
    int piece,
  ) {
    return _bitBoardForPiece(
      board,
      piece,
    );
  }

  late final _bitBoardForPiecePtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(Board, Piece)>>(
          'bitBoardForPiece');
  late final _bitBoardForPiece =
      _bitBoardForPiecePtr.asFunction<int Function(Board, int)>();

  int whitePiecesBitBoard(
    Board board,
  ) {
    return _whitePiecesBitBoard(
      board,
    );
  }

  late final _whitePiecesBitBoardPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(Board)>>(
          'whitePiecesBitBoard');
  late final _whitePiecesBitBoard =
      _whitePiecesBitBoardPtr.asFunction<int Function(Board)>();

  int blackPiecesBitBoard(
    Board board,
  ) {
    return _blackPiecesBitBoard(
      board,
    );
  }

  late final _blackPiecesBitBoardPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(Board)>>(
          'blackPiecesBitBoard');
  late final _blackPiecesBitBoard =
      _blackPiecesBitBoardPtr.asFunction<int Function(Board)>();

  int allPiecesBitBoard(
    Board board,
  ) {
    return _allPiecesBitBoard(
      board,
    );
  }

  late final _allPiecesBitBoardPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(Board)>>(
          'allPiecesBitBoard');
  late final _allPiecesBitBoard =
      _allPiecesBitBoardPtr.asFunction<int Function(Board)>();

  /// Returns the piece at a specific index
  int pieceAtIndex(
    Board board,
    int index,
  ) {
    return _pieceAtIndex(
      board,
      index,
    );
  }

  late final _pieceAtIndexPtr =
      _lookup<ffi.NativeFunction<Piece Function(Board, ffi.Int)>>(
          'pieceAtIndex');
  late final _pieceAtIndex =
      _pieceAtIndexPtr.asFunction<int Function(Board, int)>();

  /// Will toggle (XOR with 1) the bits at a specific index for a piece to the opposite state.
  /// If you pass in the NOPIECE piece (0) it will lead to undefined behaviour
  void togglePieceAtIndex(
    ffi.Pointer<Board> board,
    int index,
    int piece,
  ) {
    return _togglePieceAtIndex(
      board,
      index,
      piece,
    );
  }

  late final _togglePieceAtIndexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<Board>, ffi.Int, Piece)>>('togglePieceAtIndex');
  late final _togglePieceAtIndex = _togglePieceAtIndexPtr
      .asFunction<void Function(ffi.Pointer<Board>, int, int)>();

  /// Converts and puts the information in the piece's `array` to the `result` board.
  /// The index of a piece in the array represents its position on the board.
  /// 0 is the top left corner, and 63 is the bottom right corner.
  void fromArray(
    ffi.Pointer<Board> result,
    ffi.Pointer<Piece> array,
  ) {
    return _fromArray(
      result,
      array,
    );
  }

  late final _fromArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<Board>, ffi.Pointer<Piece>)>>('fromArray');
  late final _fromArray = _fromArrayPtr
      .asFunction<void Function(ffi.Pointer<Board>, ffi.Pointer<Piece>)>();

  late final ffi.Pointer<ffi.Pointer<ZobristRandomNumber>>
      _zobristRandomNumber =
      _lookup<ffi.Pointer<ZobristRandomNumber>>('zobristRandomNumber');

  ffi.Pointer<ZobristRandomNumber> get zobristRandomNumber =>
      _zobristRandomNumber.value;

  set zobristRandomNumber(ffi.Pointer<ZobristRandomNumber> value) =>
      _zobristRandomNumber.value = value;

  ffi.Pointer<ChessGame> newChessGame(
    ffi.Pointer<ChessGame> result,
    ffi.Pointer<ffi.Char> fenString,
  ) {
    return _newChessGame(
      result,
      fenString,
    );
  }

  late final _newChessGamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ChessGame> Function(
              ffi.Pointer<ChessGame>, ffi.Pointer<ffi.Char>)>>('newChessGame');
  late final _newChessGame = _newChessGamePtr.asFunction<
      ffi.Pointer<ChessGame> Function(
          ffi.Pointer<ChessGame>, ffi.Pointer<ffi.Char>)>();

  void freeChessGame(
    ffi.Pointer<ChessGame> chessGame,
  ) {
    return _freeChessGame(
      chessGame,
    );
  }

  late final _freeChessGamePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ChessGame>)>>(
          'freeChessGame');
  late final _freeChessGame =
      _freeChessGamePtr.asFunction<void Function(ffi.Pointer<ChessGame>)>();

  void zobristKeyInitialize() {
    return _zobristKeyInitialize();
  }

  late final _zobristKeyInitializePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('zobristKeyInitialize');
  late final _zobristKeyInitialize =
      _zobristKeyInitializePtr.asFunction<void Function()>();

  void zobristKeyTerminate() {
    return _zobristKeyTerminate();
  }

  late final _zobristKeyTerminatePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('zobristKeyTerminate');
  late final _zobristKeyTerminate =
      _zobristKeyTerminatePtr.asFunction<void Function()>();

  /// This function should be called only once when creating the your initial ChessGame struct
  /// Subsequent Zobrist key will be calculated by the makeMove function incrementally
  void calculateZobristKey(
    ffi.Pointer<ChessPosition> state,
  ) {
    return _calculateZobristKey(
      state,
    );
  }

  late final _calculateZobristKeyPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ChessPosition>)>>(
      'calculateZobristKey');
  late final _calculateZobristKey = _calculateZobristKeyPtr
      .asFunction<void Function(ffi.Pointer<ChessPosition>)>();

  /// Returns true if the friendly king (for the current turn) is in check
  /// Only valid after getValidMoves is called
  bool isKingInCheck() {
    return _isKingInCheck();
  }

  late final _isKingInCheckPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('isKingInCheck');
  late final _isKingInCheck = _isKingInCheckPtr.asFunction<bool Function()>();

  /// Returns true if the friendly king (for the current turn) is in double check
  /// Only valid after getValidMoves is called
  bool isKingInDoubleCheck() {
    return _isKingInDoubleCheck();
  }

  late final _isKingInDoubleCheckPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function()>>('isKingInDoubleCheck');
  late final _isKingInDoubleCheck =
      _isKingInDoubleCheckPtr.asFunction<bool Function()>();

  /// Computes the valid moves in a given position and stores the moves in the result array
  /// and the amount of moves in the numMoves pointer
  void getValidMoves(
    ffi.Pointer<Move> result,
    ffi.Pointer<ffi.Int> numMoves,
    ffi.Pointer<ChessGame> game,
  ) {
    return _getValidMoves(
      result,
      numMoves,
      game,
    );
  }

  late final _getValidMovesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Move>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ChessGame>)>>('getValidMoves');
  late final _getValidMoves = _getValidMovesPtr.asFunction<
      void Function(
          ffi.Pointer<Move>, ffi.Pointer<ffi.Int>, ffi.Pointer<ChessGame>)>();

  /// Makes the move and updates the ChessGame
  /// The move is assumed to be legal
  void makeMove(
    int move,
    ffi.Pointer<ChessGame> game,
  ) {
    return _makeMove(
      move,
      game,
    );
  }

  late final _makeMovePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(Move, ffi.Pointer<ChessGame>)>>(
      'makeMove');
  late final _makeMove =
      _makeMovePtr.asFunction<void Function(int, ffi.Pointer<ChessGame>)>();

  /// Returns the best move in a position (according to the computer)
  /// TODO: Implement time control later
  int think(
    ffi.Pointer<ChessGame> game,
  ) {
    return _think(
      game,
    );
  }

  late final _thinkPtr =
      _lookup<ffi.NativeFunction<Move Function(ffi.Pointer<ChessGame>)>>(
          'think');
  late final _think =
      _thinkPtr.asFunction<int Function(ffi.Pointer<ChessGame>)>();
}

class ChessPosition extends ffi.Struct {
  external Board board;

  @ffi.Int32()
  external int colorToGo;

  @ffi.Char()
  external int castlingPerm;

  @ffi.Int()
  external int enPassantTargetSquare;

  @ffi.Int()
  external int turnsForFiftyRule;

  @ffi.Int()
  external int nbMoves;

  @ZobristKey()
  external int key;
}

/// A struct which holds the information of the chess board, so which piece is at which square.
/// Use the pieceAtIndex function to extract that information
class Board extends ffi.Struct {
  @ffi.Array.multi([14])
  external ffi.Array<ffi.Uint64> bitboards;
}

abstract class PieceCharacteristics {
  static const int NOPIECE = 0;
  static const int KING = 1;
  static const int KNIGHT = 2;
  static const int BISHOP = 3;
  static const int QUEEN = 4;
  static const int ROOK = 5;
  static const int PAWN = 6;
  static const int WHITE = 8;
  static const int BLACK = 16;
}

typedef ZobristKey = ffi.Uint64;

/// A piece is char that contains the color and the type of the piece.
/// The piece type is in the first 3 least significant bits.
/// The piece color is the next 2 bits that follow the piece type bits
/// The first 3 most significant bits of the char are unused.
/// Use the pieceColor(piece) function or pieceType(piece) function to extract those information
/// Use the makePiece(color, type) function to create a valid Piece
typedef Piece = ffi.Char;

class ZobristRandomNumber extends ffi.Struct {
  @ffi.Array.multi([9])
  external ffi.Array<ffi.Uint64> enPassantFile;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint64> castlingPerms;

  @ffi.Array.multi([14, 64])
  external ffi.Array<ffi.Array<ffi.Uint64>> pieces;

  @ffi.Uint64()
  external int sideToMove;
}

/// Represents a game of chess.
/// currentState holds all information of a position (same information that is in a fen string)
/// Zobrist keys are used to quickly compute repetitions
class ChessGame extends ffi.Struct {
  external ffi.Pointer<ChessPosition> currentState;

  external ffi.Pointer<ZobristKey> previousStates;

  @ffi.Int()
  external int previousStatesCount;

  @ffi.Int()
  external int previousStatesCapacity;
}

/// The structure is copied from Sebastian Lague chess program
/// A move is a 16 bit number
/// bit 0-5: from square (0 to 63)
/// bit 6-11: to square (0 to 63)
/// bit 12-15: flag
typedef Move = ffi.UnsignedShort;
